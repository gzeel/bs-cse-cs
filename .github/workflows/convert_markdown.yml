name: Convert Markdown to HTML

on:
  push:
    branches:
      - "**"
      - "!docs" # Exclude docs branch to avoid circular triggers
    paths:
      - "**/*.md" # Only trigger on markdown file changes

jobs:
  convert-markdown:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for proper branch handling

      - name: List markdown files
        run: |
          echo "Markdown files in the repository:"
          find . -name "*.md" | sort

      - name: Set up Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install dependencies
        run: |
          npm init -y
          npm install markdown-it markdown-it-highlightjs highlight.js
          npm install markdown-it-anchor markdown-it-toc-done-right

      - name: Create conversion script
        run: |
          cat > convert.js << 'EOF'
          const fs = require('fs').promises;
          const path = require('path');
          const MarkdownIt = require('markdown-it');
          const highlightjs = require('markdown-it-highlightjs');
          const anchor = require('markdown-it-anchor');
          const toc = require('markdown-it-toc-done-right');

          // Initialize markdown parser with plugins
          const md = new MarkdownIt({
            html: true,
            linkify: true,
            typographer: true
          })
          .use(highlightjs, {
            auto: true,
            inline: true
          })
          .use(anchor, {
            permalink: anchor.permalink.ariaHidden({
              placement: 'after',
              class: 'anchor',
              symbol: '#',
              ariaHidden: true,
            }),
            level: [1, 2, 3, 4, 5, 6]
          })
          .use(toc, {
            level: [2, 3],
            listType: 'ul',
            listClass: 'toc-list',
            itemClass: 'toc-item',
            linkClass: 'toc-link'
          });

          // HTML template with GitHub-like styling
          const htmlTemplate = (content, title, tocContent) => `
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${title}</title>
            <style>
              :root {
                /* GitHub Light Variables */
                --color-canvas-default: #ffffff;
                --color-canvas-subtle: #f6f8fa;
                --color-border-default: #d0d7de;
                --color-border-muted: #d8dee4;
                --color-neutral-muted: rgba(175, 184, 193, 0.2);
                --color-accent-fg: #0969da;
                --color-accent-emphasis: #0969da;
                --color-danger-fg: #cf222e;
                --color-fg-default: #24292f;
                --color-fg-muted: #57606a;
                --color-fg-subtle: #6e7781;
                --color-success-fg: #1a7f37;
                --color-attention-fg: #9a6700;
                --color-header-bg: #24292f;
                --color-header-fg: #ffffff;
                --color-header-logo: #ffffff;
                --color-header-search-bg: #24292f;
                --color-header-search-border: #57606a;
                --color-code-block-bg: #f6f8fa;
                --color-code-block-border: #d0d7de;
              }
              
              body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
                line-height: 1.5;
                color: var(--color-fg-default);
                background-color: var(--color-canvas-default);
                max-width: 1012px;
                margin: 0 auto;
                padding: 32px;
                font-size: 16px;
              }
              
              /* Layout */
              .markdown-body {
                position: relative;
                margin-bottom: 16px;
                padding: 32px;
                border: 1px solid var(--color-border-default);
                border-radius: 6px;
                background-color: var(--color-canvas-default);
              }
              
              /* Table of Contents */
              .toc-container {
                margin-bottom: 32px;
                padding: 16px;
                background-color: var(--color-canvas-subtle);
                border: 1px solid var(--color-border-default);
                border-radius: 6px;
              }
              
              .toc-header {
                font-size: 16px;
                font-weight: 600;
                margin-top: 0;
                margin-bottom: 8px;
              }
              
              .toc-list {
                padding-left: 20px;
                margin-bottom: 0;
              }
              
              .toc-item {
                margin: 4px 0;
              }
              
              .toc-link {
                color: var(--color-accent-fg);
                text-decoration: none;
              }
              
              .toc-link:hover {
                text-decoration: underline;
              }
              
              /* Typography */
              h1, h2, h3, h4, h5, h6 {
                margin-top: 24px;
                margin-bottom: 16px;
                font-weight: 600;
                line-height: 1.25;
                padding-bottom: 0.3em;
              }
              
              h1 {
                font-size: 2em;
                margin-top: 0;
                border-bottom: 1px solid var(--color-border-muted);
              }
              
              h2 {
                font-size: 1.5em;
                border-bottom: 1px solid var(--color-border-muted);
              }
              
              h3 {
                font-size: 1.25em;
              }
              
              h4 {
                font-size: 1em;
              }
              
              h5 {
                font-size: 0.875em;
              }
              
              h6 {
                font-size: 0.85em;
                color: var(--color-fg-muted);
              }
              
              a {
                color: var(--color-accent-fg);
                text-decoration: none;
              }
              
              a:hover {
                text-decoration: underline;
              }
              
              .anchor {
                float: left;
                padding-right: 4px;
                margin-left: -20px;
                line-height: 1;
                display: inline-block;
                color: var(--color-fg-muted);
                opacity: 0;
                text-decoration: none;
              }
              
              h1:hover .anchor,
              h2:hover .anchor,
              h3:hover .anchor,
              h4:hover .anchor,
              h5:hover .anchor,
              h6:hover .anchor {
                opacity: 1;
              }
              
              /* Text elements */
              p {
                margin-top: 0;
                margin-bottom: 16px;
              }
              
              blockquote {
                padding: 0 1em;
                color: var(--color-fg-muted);
                border-left: 0.25em solid var(--color-border-default);
                margin: 0 0 16px 0;
              }
              
              ul, ol {
                padding-left: 2em;
                margin-top: 0;
                margin-bottom: 16px;
              }
              
              li {
                margin-top: 0.25em;
              }
              
              li + li {
                margin-top: 0.25em;
              }
              
              /* Code */
              code {
                font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
                padding: 0.2em 0.4em;
                margin: 0;
                font-size: 85%;
                background-color: var(--color-neutral-muted);
                border-radius: 6px;
              }
              
              pre {
                font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
                padding: 16px;
                overflow: auto;
                font-size: 85%;
                line-height: 1.45;
                background-color: var(--color-code-block-bg);
                border-radius: 6px;
                margin-top: 0;
                margin-bottom: 16px;
                word-wrap: normal;
                border: 1px solid var(--color-code-block-border);
              }
              
              pre code {
                font-size: 100%;
                padding: 0;
                margin: 0;
                background-color: transparent;
                border: 0;
                white-space: pre;
                word-break: normal;
              }
              
              /* Tables */
              table {
                display: block;
                width: 100%;
                width: max-content;
                max-width: 100%;
                overflow: auto;
                border-spacing: 0;
                border-collapse: collapse;
                margin-top: 0;
                margin-bottom: 16px;
              }
              
              table th {
                font-weight: 600;
              }
              
              table th,
              table td {
                padding: 6px 13px;
                border: 1px solid var(--color-border-default);
              }
              
              table tr {
                background-color: var(--color-canvas-default);
                border-top: 1px solid var(--color-border-muted);
              }
              
              table tr:nth-child(2n) {
                background-color: var(--color-canvas-subtle);
              }
              
              /* Images */
              img {
                max-width: 100%;
                box-sizing: content-box;
                background-color: var(--color-canvas-default);
                border-radius: 6px;
              }
              
              /* Markdown extras */
              hr {
                height: 0.25em;
                padding: 0;
                margin: 24px 0;
                background-color: var(--color-border-default);
                border: 0;
              }
              
              /* GitHub syntax highlighting */
              .hljs-doctag,
              .hljs-keyword,
              .hljs-meta .hljs-keyword,
              .hljs-template-tag,
              .hljs-template-variable,
              .hljs-type,
              .hljs-variable.language_ {
                color: #d73a49;
              }
              
              .hljs-title,
              .hljs-title.class_,
              .hljs-title.class_.inherited__,
              .hljs-title.function_ {
                color: #6f42c1;
              }
              
              .hljs-attr,
              .hljs-attribute,
              .hljs-literal,
              .hljs-meta,
              .hljs-number,
              .hljs-operator,
              .hljs-selector-attr,
              .hljs-selector-class,
              .hljs-selector-id,
              .hljs-variable {
                color: #005cc5;
              }
              
              .hljs-meta .hljs-string,
              .hljs-regexp,
              .hljs-string {
                color: #032f62;
              }
              
              .hljs-built_in,
              .hljs-symbol {
                color: #e36209;
              }
              
              .hljs-comment,
              .hljs-code,
              .hljs-formula {
                color: #6a737d;
              }
              
              .hljs-name,
              .hljs-quote,
              .hljs-selector-tag,
              .hljs-selector-pseudo {
                color: #22863a;
              }
              
              .hljs-deletion {
                color: #b31d28;
                background-color: #ffeef0;
              }
              
              .hljs-addition {
                color: #22863a;
                background-color: #f0fff4;
              }
            </style>
          </head>
          <body>
            ${tocContent ? `
            <div class="toc-container">
              <h3 class="toc-header">Table of Contents</h3>
              ${tocContent}
            </div>
            ` : ''}
            
            <div class="markdown-body">
              ${content}
            </div>
          </body>
          </html>
          `;

          // Process images in HTML content and prepare them for copying
          function processImages(html, mdFilePath, outputPath) {
            console.log(`Processing images for ${mdFilePath} -> ${outputPath}`);
            
            const outputDir = path.dirname(outputPath);
            const imagesDir = path.join(outputDir, 'images');
            const imagesToCopy = [];
            
            // Fix image paths and collect images that need to be copied
            const processedHtml = html.replace(/<img([^>]*)src="([^"]+)"([^>]*)>/g, (match, before, src, after) => {
              // Skip absolute URLs or data URLs
              if (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('data:')) {
                console.log(`  - Skipping external image: ${src}`);
                return match;
              }
              
              // Get the actual image filename
              const imageName = path.basename(src);
              console.log(`  - Found image: ${imageName} (source: ${src})`);
              
              // Compute the source path (where the image currently is)
              const mdDir = path.dirname(mdFilePath);
              let imagePath;
              
              // Handle absolute and relative paths
              if (src.startsWith('/')) {
                // Absolute path from repo root
                imagePath = path.join('.', src);
              } else {
                // Relative path from markdown file
                imagePath = path.join(mdDir, src);
              }
              
              console.log(`  - Source path: ${imagePath}`);
              console.log(`  - Destination: ${path.join(imagesDir, imageName)}`);
              
              // Add to the list of images to copy
              imagesToCopy.push({
                source: imagePath,
                destination: path.join(imagesDir, imageName)
              });
              
              // Return updated img tag with the new path
              return `<img${before}src="images/${imageName}"${after}>`;
            });
            
            return { processedHtml, imagesToCopy };
          }

          async function findMarkdownFiles(directory) {
            const fileList = [];
            
            async function traverse(dir) {
              const files = await fs.readdir(dir, { withFileTypes: true });
              
              for (const file of files) {
                const fullPath = path.join(dir, file.name);
                
                if (file.isDirectory()) {
                  // Skip node_modules and .git directories
                  if (file.name !== 'node_modules' && file.name !== '.git') {
                    await traverse(fullPath);
                  }
                } else if (file.name.endsWith('.md')) {
                  fileList.push(fullPath);
                }
              }
            }
            
            await traverse(directory);
            console.log(`Found ${fileList.length} markdown files to process`);
            return fileList;
          }

          async function convertMarkdownToHtml(mdFilePath, outputDir) {
            try {
              console.log(`\nConverting ${mdFilePath} to HTML...`);
              
              // Read markdown content
              const mdContent = await fs.readFile(mdFilePath, 'utf8');
              console.log(`Read ${mdContent.length} bytes from ${mdFilePath}`);
              
              // Get title from first heading or filename
              let title = path.basename(mdFilePath, '.md');
              const headingMatch = mdContent.match(/^#\s+(.+)$/m);
              if (headingMatch) {
                title = headingMatch[1];
              }
              console.log(`Document title: ${title}`);
              
              // Generate TOC
              let tocContent = '';
              const contentWithTocPlaceholder = mdContent.includes('[TOC]') 
                ? mdContent 
                : '[TOC]\n\n' + mdContent;
              
              // Convert markdown to HTML
              const htmlContent = md.render(contentWithTocPlaceholder);
              console.log(`Generated ${htmlContent.length} bytes of HTML`);
              
              // Extract TOC
              const tocMatch = htmlContent.match(/<nav class="table-of-contents">([\s\S]*?)<\/nav>/);
              if (tocMatch) {
                tocContent = tocMatch[1];
                console.log(`Found table of contents`);
              }
              
              // Remove the TOC placeholder from the content
              let contentWithoutToc = htmlContent.replace(/<nav class="table-of-contents">[\s\S]*?<\/nav>/, '');
              
              // Determine file paths
              const relativePath = path.relative('.', mdFilePath);
              const outputPath = path.join(outputDir, relativePath.replace(/\.md$/, '.html'));
              console.log(`Output path: ${outputPath}`);
              
              // Create directory structure if it doesn't exist
              await fs.mkdir(path.dirname(outputPath), { recursive: true });
              
              // Process images
              const { processedHtml, imagesToCopy } = processImages(contentWithoutToc, mdFilePath, outputPath);
              
              // Create images directory if needed
              if (imagesToCopy.length > 0) {
                const imagesDir = path.join(path.dirname(outputPath), 'images');
                await fs.mkdir(imagesDir, { recursive: true });
                console.log(`Created images directory: ${imagesDir}`);
              }
              
              // Copy images
              for (const image of imagesToCopy) {
                try {
                  // Check if the source image exists
                  try {
                    await fs.access(image.source);
                    console.log(`Image found: ${image.source}`);
                  } catch (err) {
                    console.warn(`Warning: Image not found: ${image.source}`);
                    continue;
                  }
                  
                  // Create parent directories if needed
                  await fs.mkdir(path.dirname(image.destination), { recursive: true });
                  
                  // Copy the image
                  await fs.copyFile(image.source, image.destination);
                  console.log(`Copied image to: ${image.destination}`);
                } catch (error) {
                  console.warn(`Warning: Failed to copy image ${image.source}: ${error.message}`);
                }
              }
              
              // Write HTML file
              await fs.writeFile(outputPath, htmlTemplate(processedHtml, title, tocContent));
              console.log(`✓ Created HTML file: ${outputPath}`);
              
              return outputPath;
            } catch (error) {
              console.error(`Error converting ${mdFilePath}:`, error);
              throw error; // Rethrow to handle in main
            }
          }

          async function main() {
            try {
              console.log('Starting markdown to HTML conversion...');
              const outputDir = 'html_output';
              
              // Create output directory
              await fs.mkdir(outputDir, { recursive: true });
              console.log(`Created output directory: ${outputDir}`);
              
              // Find all markdown files
              const mdFiles = await findMarkdownFiles('.');
              if (mdFiles.length === 0) {
                console.log('No markdown files found!');
                return;
              }
              
              // Convert each markdown file to HTML
              const results = [];
              for (const mdFile of mdFiles) {
                try {
                  const outputPath = await convertMarkdownToHtml(mdFile, outputDir);
                  results.push({ mdFile, outputPath, success: true });
                } catch (error) {
                  results.push({ mdFile, error: error.message, success: false });
                }
              }
              
              // Print summary
              console.log('\n=== Conversion Summary ===');
              console.log(`Total markdown files: ${mdFiles.length}`);
              const successCount = results.filter(r => r.success).length;
              console.log(`Successfully converted: ${successCount}`);
              console.log(`Failed conversions: ${results.length - successCount}`);
              
              if (results.length - successCount > 0) {
                console.log('\nFailed conversions:');
                results.filter(r => !r.success).forEach(r => {
                  console.log(`- ${r.mdFile}: ${r.error}`);
                });
              }
              
              // List all HTML files and images
              console.log('\nGenerated files:');
              await listFiles(outputDir);
              
              console.log('\nConversion completed!');
            } catch (error) {
              console.error('Fatal error during conversion:', error);
              process.exit(1);
            }
          }

          async function listFiles(dir) {
            const files = [];
            
            async function traverse(currentDir, indent = '') {
              const entries = await fs.readdir(currentDir, { withFileTypes: true });
              
              for (const entry of entries) {
                const fullPath = path.join(currentDir, entry.name);
                
                if (entry.isDirectory()) {
                  console.log(`${indent}📁 ${entry.name}/`);
                  await traverse(fullPath, indent + '  ');
                } else {
                  console.log(`${indent}📄 ${entry.name}`);
                  files.push(fullPath);
                }
              }
            }
            
            await traverse(dir);
            return files;
          }

          main();
          EOF

      - name: Run conversion script
        run: |
          echo "=== Starting markdown conversion ==="
          node convert.js
          echo "=== Conversion complete ==="

          if [ -d "html_output" ]; then
            echo "=== Generated HTML files ==="
            find html_output -type f -name "*.html" | sort
            
            echo "=== Checking for images ==="
            find html_output -type d -name "images" | xargs -I {} ls -la {} 2>/dev/null || echo "No images directory found"
          else
            echo "ERROR: html_output directory not found!"
            exit 1
          fi

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

      - name: Create/checkout docs branch
        run: |
          echo "=== Setting up docs branch ==="
          # Check if the docs branch exists in the remote
          if git ls-remote --heads origin docs; then
            echo "docs branch exists, checking out"
            git fetch origin docs
            git checkout docs
          else
            echo "docs branch doesn't exist, creating it"
            git checkout --orphan docs
            git rm -rf .
            touch README.md
            echo "# Documentation" > README.md
            git add README.md
            git commit -m "Initial docs branch commit"
          fi

          echo "Current branch: $(git branch --show-current)"
          ls -la

      - name: Copy files to docs branch
        run: |
          echo "=== Copying HTML files to docs branch ==="

          # Before state
          echo "Files in docs branch before:"
          ls -la

          # Create a temporary directory for holding files
          mkdir -p /tmp/html_output_copy
          cp -r html_output/* /tmp/html_output_copy/

          # Clean everything except .git directory
          find . -mindepth 1 -not -path "./.git*" -delete

          # Copy the HTML output back
          cp -r /tmp/html_output_copy/* .

          # After state
          echo "Files in docs branch after copy:"
          find . -type f | grep -v "^./.git" | sort

          # Check for specific directories
          if [ -d "$(find . -type d -name 'images' | head -1)" ]; then
            echo "✓ Images directory present"
            find . -name "images" -type d | xargs -I {} ls -la {}
          else
            echo "✗ No images directory found"
          fi

      - name: Commit and push to docs branch
        run: |
          echo "=== Committing changes to docs branch ==="
          git add .

          if git status --porcelain | grep .; then
            echo "Changes detected, committing..."
            git commit -m "Convert Markdown to HTML from branch ${GITHUB_REF#refs/heads/}"
            echo "Pushing to docs branch..."
            git remote set-url origin https://x-access-token:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/${{ github.repository }}
            git push origin docs
            echo "✓ Successfully pushed to docs branch"
          else
            echo "No changes to commit"
          fi

      - name: Summary
        run: |
          echo "=== Workflow Summary ==="
          echo "✓ Markdown files processed"
          echo "✓ HTML files generated"
          echo "✓ Changes pushed to docs branch"
          echo "View your documentation at: https://github.com/${{ github.repository }}/tree/docs"
